
[ROOT_VC pushVCWithType:type andDict:nil animated:YES];

-----------------------------------------------------------------------------------
#define LOCAL_CURRENT_REGION                            @"CurrentRegion"
#define LOCAL_CURRENT_REGION_NAME                       @"CurrentRegionName"
#define LOCAL_CURRENT_REGION_TITLE_NAME					@"CurrentRegionTitleName"
#define LOCAL_CURRENT_LANGUAGE                          @"CurrentLanguage"
#define LOCAL_API_TOKEN_KEY                             @"ApiTokenKey"
#define LOCAL_CURRENT_AREA_CODE                         @"CurrentAreaCode"
-----------------------------------------------------------------------------------
1. 公共类的封装
	> UI控件的增强 - Catagory
	> 宏定义

		> AppConfig.h: 
			> 定义一些项目APP有关的宏(sinaWeiBo..)

		> Common-Config.h: 
			> NSLog打印的宏代替
			> 项目所有用到的通知(NSNotification)的Key
			> 常用方法
				> 设置/获取当前APP的语言环境
				> 获取国际化文件的key对应的value
				> 获取OS_Version , 屏幕尺寸 , 屏幕方向 

		> Config.h
			> APP相关配置
				> APP_TYPE: 当前项目代码APP 所适合的硬件平台(Android/iPhone/WindowsPhone..)
				> APP_VER: APP的 版本号 -- [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleShortVersionString"];
				> API_VER: 项目代码的 版本号
			> 常用单例对象的宏定义
				> #define APP_DELEGATE  		(AppDelegate*)[[UIApplication sharedApplication] delegate]
				> #define ROOT_VC				[APP_DELEGATE rootVC]
-----------------------------------------------------------------------------------
> 创建多个target, 来对应不同语言环境下得应用差异化
	> 每个target下得 Preprocessor Macros 
		> CN=1 、HK=1 ...


> 使用宏定义 ，区分不同版本的app (美国、日本、中国、香港...)

	#if (VERSION == 版本ID)
		...
	#else 
		...
	#endif

-----------------------------------------------------------------------------------
				> 项目所有模块对应的 - 网络请求manager对象 - 单例对象的宏定义
					-- 每一个模块的网络请求都封装到对应的 XxxManager类 中

					>将服务器JSON数据 --> 实体对象  的Manager
					#define JSON_MANAGER                (JsonManager *)[[AppManager sharedAppManager] jsonManager]

					>所有网络请求的Manager
				 	#define APP_MANAGER					[AppManager sharedAppManager]
					#define RESTAURANT_MANAGER          (RestaurantManager *)[[AppManager sharedAppManager] restaurantManager]
					#define RESTAURANT_DETAIL_MANAGER   (RestaurantDetailManager *)[[AppManager sharedAppManager] ]
					#define BUFFET_MANAGER              (BuffetManager *)[[AppManager sharedAppManager] buffetManager]
					#define HOTPOT_MANAGER              (HotpotManager *)[[AppManager sharedAppManager] hotpotManager]
					#define REVIEW_MANAGER              (ReviewManager *)[[AppManager sharedAppManager] reviewManager]
					#define PHOTO_MANAGER               (PhotoManager *)[[AppManager sharedAppManager] photoManager]
					#define SETTING_MANAGER             (SettingManager *)[[AppManager sharedAppManager] settingManager]
					#define FONT_MANAGER                (FontManager *)[[AppManager sharedAppManager] fontManager]
					#define CHART_MANAGER               (ChartManager *)[[AppManager sharedAppManager] chartManager]
					#define HOTNEWS_MANAGER             (HotnewsManager *)[[AppManager sharedAppManager] hotnewsManager]
					#define INDEX_MANAGER               (IndexManager *)[[AppManager sharedAppManager] indexManager]
					#define SEARCH_MANAGER              (SearchManager *)[[AppManager sharedAppManager] searchManager]
					#define DATABASE_MANAGER            (DatabaseManager *)[[AppManager sharedAppManager] databaseManager]
					#define BOOKMARK_MANAGER            (BookmarkManager *)[[AppManager sharedAppManager] bookmarkManager]
					#define ACCOUNT_MANAGER             (AccountManager *)[[AppManager sharedAppManager] accountManager]
					#define COUPON_MANAGER              (CouponManager *)[[AppManager sharedAppManager] couponManager]
					#define FACEBOOK_MANAGER            (FacebookManager *)[[AppManager sharedAppManager] facebookManager]
					#define CONTACTUS_MANAGER           (ContactUsManager *)[[AppManager sharedAppManager] contactUsManager]
					#define PAYPAL_MANAGER              (PayPalManager *)[[AppManager sharedAppManager] paypalManager]
					#define TWITTER_MANAGER             (TwitterManager *)[[AppManager sharedAppManager] twitterManager]
					#define GA_MANAGER                  (GAManager *)[[AppManager sharedAppManager] gaManager]
					#define PUSH_MANAGER                (PushManager *)[[AppManager sharedAppManager] pushManager]
					> 是用Manager来封装网络请求的优点:
						让Manager类类直接耦合ASIHTTPRequest或MKNetWorkKit
						而项目中只需要耦合Manager类
						项目其他类就没有直接耦合第三方库的代码
						日后改为另一个网络第三方库实现网络请求，就不会给项目带来很大的麻烦，只需要改动所有的Manager即可，其他项目代码不用改
---------------------------------------------------------------------------------
					> 一切网络请求 --> 异步
						给Manager设置一个回调Block , 用于请求成功后 , 让Manager回传Json解析后的实体对象数据

----------------------------------------------------------------------------------

		> plist文件: 
			> 定义APP内需要的配置内容(key-value)
-------------------------------------------------------------------------------

2. 项目的类结构
	
	> 基类
		> BaseViewController
			控制器基类 , 用于写一些控制器所具有相同的功能(部分代码)
		> BaseUIView
			一些视图view的基类
			> UI控件中可以加入异步加载图片(其他数据)的代码 - 回调block中，更新UI要显示的数据

	> 一个模块所包含的

		> ViewControllers(一个模块包含多个显示界面--多个控制器 来管理):
			继承自 BaseViewController

			> 一个ViewController的代码结构:
				> init方法
					初始化所有需要显示的UI控件 、 工具类 

				> ViewDidLoad方法
					> initSubViews方法
						> 初始化UI控件 , 添加到 ViewController.view 上
						> 初始化子控件 , 分模块、分步骤、分方法 , 来按顺序创建 UI控件对象 , 并添加到 Controller.view

				> 给Manager设置的回调Block被调用后 , 给创建好的 UI控件对象 设置需要显示的数据

				> 点击事件 ---- (一个按钮 一定是对应 一个控制器)
					> UIButton: 
						push之前, 先给子控制器 setXxxx 需要的参数值
						self.navigationController.pushViewController:其他子控制器
					> UITableViewCell: 
						push之前, 先给子控制器 setXxxx 需要的参数值
						self.navigationController.pushViewController:其他子控制器
---------------------------------------------------------------------------------
				> didReceiveMemoryWarining方法
					> 释放当前控制器, 所不需要的 UI控件对象、代理对象、Manager对象、各种缓存数据...
						> 判断当前控制器 在UINavigatioController的控制器栈中 是否处于底部  -- 判断当前控制器 是否是 RootViewController
							> 不是, 直接释放掉该控制器所持有的所有对象
								> controller.subViews(成员变量形式) 一个一个接着 release
								> @property属性 = nil;
								> 代理对象 = nil;
----------------------------------------------------------------------------------
				> dealloc方法
					> [成员变量 release];
					> @property属性 = nil;
					> delegate = nil; 

--------------------------------------------------------------------------------
				> setXxx方法 (类指针，数组..)
					> 1. [当前成员变量 release]; //对nil的指针进行release，不会报错
					> 2. 当前成员变量 = [传进来的指针变量 retain];
-----------------------------------------------------------------------------------------
				> ASIFormDataRequest创建、异步请求、内存管理
					> 1. 声明成员变量 ASIFormDataRequest *request;
					> 2. 取消request指针所有之前数据
							[request clearDelegatesAndCancel];
							[request release];
					> 3. 创建ASIFormDataRequest对象
							request = [[xxx_xxxManager getXXXXXX: callBack:@selector(didGetPhotoDetail:)] retain];
					> 4. 回调函数didGetPhotoDetail:接收响应的json, 并解析成实体对象返回
					> 5. dealloc方法中，对request指针指向的ASIFormDataRequest对象释放
							[request release];
							requet = nil;
------------------------------------------------------------------------------------

		> views: 
			继承自 BaseUIView
		> Manager:
			封装该模块(控制器)所有的网络请求代码实现细节
			ViewController给Manager设置回调Block代码 , 等待数据成功响应返回后 , 才来更新UI上显示的数据
		> Modules:
			所有该模块相关的实体类 - Entity
			> 对象(数据)的存储
				> plist - 本地文件 - 序列化对象
				> UserDefault - 内存 - 键值对形式存储
				> CoreData -关系型数据库 - 存储
				> SQLite API - sqlite嵌入式数据库 - 存储

3. App启动流程
-------------------------------------------------------------------
	> AppDelegate
		> [AppDelegate.window setRootViewController:RoorViewController];
--------------------------------------------------------------------------------

> NavigationBaseViewController
	
	> initRightBtn方法 - 控制导航栏按钮显示
		> controller.navigationItem.leftBarButtonItem
		> controller.navigationItem.rightBarButtonItem


> RootViewController 

	(不显示数据,只是一个界面框架布局的容器,并且实现了UINavigationControllerDelegate)

		> RootViewController.viewDidLoad方法  
			> initSubViews方法
				> IndexPageViewController -- APP主界面控制器 -- [RootViewController.view addSUbview:IndexPageViewController.view];
					> 子视图:searchBoxView:QuickSearchBoxView -- IndexPageViewController.view 顶部搜索框
					> 子视图:bannerSV:UIScrollView -- IndexPageViewController.view 中间的滚动广告栏
					> 子视图:iconSV:UIScrollView -- IndexPageViewController.view 底部的所有子选项按钮群
						> 创建从IndexPageViewController.view主页 , 点击按钮 ,push到另外的子控制器的按钮选项
							> relayoutIndexIcon方法
								> 获取所有push按钮的图片 -- 通过Manager访问coreData本地数据库文件
								> 创建每一个选项按钮 --> push到对应的子控制器模块
									> IndexIcon: 选项的图片
										> iconType属性: 每一个选项都有一个唯一的type值
										> iconUrl属性: 每一个选项对应的网络请求baseUrl
									> IndexIconView: 每一个选项容器View
										> 依赖一个IndexIcon对象 -- 做为内部按钮的显示的图片
										> ORButton按钮 --> 按钮点击事件 , 用来pushViewController
											> 按钮事件方法: IndexIconView.buttonAction:
												> buttonAction: -- push child viewControllers
													- (void)buttonAction:(id)sender{

														//这里调的ROOT_VC(RootViewControlelr)的push方法
														[ROOT_VC pushVCWithType:type andDict:nil animated:YES];
													}
													> 根据log出得子控制器类名 --> 找对应的ViewController
								> 将创建好的IndexIconView选项 ,一次添加到 iconSV

    RootViewController.pushVCWithType:方法 - 拦截所有viewController的pushViewController:方法
    	> 所有push出得控制器对应的编号
    		> 在Config.h定义的枚举变量
    			
    			typedef enum {
					IndexIconsTypeAdvSearch = 1,
					IndexIconsTypeNearby = 2,
					IndexIconsTypeBookmark = 3,
					IndexIconsTypeCoupon = 4,
					IndexIconsTypeReservation = 5,
					IndexIconsTypeAward = 6,
					IndexIconsTypeChart = 7,
					IndexIconsTypeRandomSearch = 8,
					IndexIconsTypeAE = 9,
					IndexIconsTypeHotpot = 10,
					IndexIconsTypeBuffet = 11,
					IndexIconsTypeHotNews = 12,
					IndexIconsTypeSeason = 13,
					IndexIconsTypeLatestReview = 14,
					IndexIconsTypeSnapShare = 15,
					IndexIconsTypeWebLink = 16,
					IndexIconsTypeRestaurantDetail = 17,
					IndexIconsTypeCouponDetail = 18,
				    IndexIconsTypeMyOpenRice = 19,
				    IndexIconsTypeHome = 20,
				    IndexIconsTypeQRScanner = 21,
				    IndexIconsTypeMyCoupons = 22,
				    IndexIconsTypeSetting = 23,
					IndexIconsTypeMyBookmark = 24,
				    // Not yet handled in App
				//    IndexIconsTypeHotNewsDetail = 25,
				    IndexIconsTypeURLScheme = 26,
				    IndexIconsTypeFBFanPage = 27

				}IndexIconsType;

		
> [ROOT_VC pushVCWithType:type andDict:nil animated:YES] 

			>1. ROOT_VC(RootViewController)实现了UINavigationControllerDelegate --> UINavigationController

			>2. ROOT_VC.pushVCWithType: andDict: animated:方法中
				> 根据传入的type值(IdexIconView.ORButton.tag)来决定classStr=type值对应的类名
				> 判断拼接完成的完整ClassName，做一些特别的处理: 加载数据、UI、..
				> 实例化该ClassName对应的控制器类
					Class vc = NSClassFromString(className);
					UIViewController *vc = [[vc alloc] init];
				> 最后调用[ROOT_VC.navigationController pushViewController:vc];
-----------------------------------------------------------------------------------------
> IndexIconView.buttonAction:

-----------------------------------------------------------------------------------------
RootViewController子view

	> DragDownMenuView -- 导航栏上得那个点击可以下拉的列表按钮

	> DragUpMenuView -- 一个ORButton按钮项 就push出 一个viewController
		
		> shareBtn -- 分享按钮
			>事件方法: shareBtnDidPress:

		> bookmarkBtn -- 收藏按钮
			>事件方法: bookmarkBtnDidPress: 
				> BookmarkView
				> BookmarkManager

		> reviewBtn -- 写评论	
			>事件方法: reviewBtnDidPress:

		> photoBtn -- 上传图片
			>事件方法: photoBtnDidPress: 
				> EditPhotoViewController 
					> @selector(openCamera) - UploadPhoto_TakePhoto
					> @selector(showImagePicker) - UploadPhoto_ChooseFromLibrary
						> 都是 present view Controller to ELCAlbumPickerController
						> EditPhotoViewController 是 ELCImagePickerController 的代理

----------------------------------------------------------------------------------------------


ORAlertViewDelegate - 弹出窗口代理


----------------------------------------------------------------------------------------------
由IndexPageViewController:relayoutIndexIcon() push出来的子控制器模块:


	> 快速定位IndexPageViewController界面底部的indexIconView的方法ß
		> IndexIconView.initWithIndexIcon:
			> 创建一个IndexIconView对象
				> 传入一个IndexIcon对象
					> 参数1) type - IndexIconView对象在IndexPageViewController底部ScrollView的排序
					> 参数2) imageUrl - 当前IndexIconView对象显示的图片
					> 参数3) iconNameLangX:(X:1,2,3) - IndexIconView要显示的标题文字

	> IndexIconView.ORButton.buttonAction:

		1.type = IndexIcon.iconType 
		[ROOT_VC pushVCWithType:type andDict:indexIconDict animated:YES];

	> SearchAdvancedSearchListViewController - Advanced Search按钮点击
		> subViews组成结构:

	> NearbyListViewController - NearBy按钮点击
		> subViews组成结构:

	> ReservationListViewController - Reservation按钮点击
		> subViews组成结构:

	> CouponListViewController - HotOffer按钮点击
		> subViews组成结构:
			> WoodBoardView (去掉)
			> [self initListTable];	加载如下2个组件
				> TotalNumberBarView - 显示当前加载的数据列表长度和页 
				> PullToRefreshTableView - 显示数据列表
					> CouponListCell

			> CouponDetailViewController - 点击跳转到的优惠券详情界面
			

	> MyOpenRiceViewController - MyOpenRice按钮点击
		> LoginScreenViewController - 先登录成功后，才能到MyOpenRiceViewController
		> subViews组成结构:

	> MyBookmarkViewController - MyRestaurant按钮点击
		> LoginScreenViewController - 先登录成功后，才能到MyOpenRiceViewController
		> subViews组成结构:
			> RegistrationView
				> submitDidPress -- 注册按钮

	> RestaurantChartViewController - Chart按钮点击
		> subViews组成结构:

	> LatestReviewViewController - Review按钮点击
		> subViews组成结构:

	> RandomListViewController - Random按钮点击 - 商店列表
		> subViews组成结构:

			> UITabkeView的dataSource、delegate方法 --> 封装在RestaurantListBaseViewController中

			> 实体类: RestaurantListItem
				> 有得实体是赞助商
					> item.isSponsor判断

			> RestaurantListCell - (cell)
				> item.isSponsor=YES
					> [self createSponsorCell:item]
				> item.isSponsor=NO
					> [self createListCellForRecordItem:item]	

			> OverviewViewController - cell点击后 push viewController
				> OverviewView - 具体展示相关subViews
					> TabsView - 选项卡切换: Info、Reiview、photo
						> 内部封装三个对应选项卡的view
							> InfoView 
								> 添加的ScrollView: 最新照片 - (en.strings:  "RestaurantInfo_Photos" = "Latest Photos" )
									> infoView.detail.thumbnailArray - NSMutableArray
										> 元素: PhotoDetail
							> ReviewView
							> WaterFallPhotoView


	> QRScannerViewController - OR Code Scanner按钮点击
		> subViews组成结构:

	> SettingViewController - Settings按钮点击
		> subViews组成结构:

	> EditPhotoViewController - DragUpMenu中得upload photo按钮 push的
		> DragUpMenu.photoBtnDidPress:按钮点击事件
			> 上传的一个图片对应的实体类 - UploadPhotoItem

	> OverviewViewController: 详情界面
		> 最上面的显示图片view
		> TabsView
			> InfoView
			> ReviewView
			> WaterFallPhotoView

	> WriteReviewViewController: 提交新的餐厅评论界面

		> WriteReviewTitleViewController - 1 - 评论标题

		> WriteReviewDiningMethodView - 2 - 用餐途径

		> WriteReviewContentViewController - 3 - 评论的正文内容
			> 保存提交评论的导航按钮的创建代码在
				> NavigationBaseViewController.initRightBtn().initNavSaveBtn()
					> ORButton的事件方法 -- WriteReviewViewController.navSaveBtnAction:方法
						> 创建一个弹出窗口 - ORAlertView
							> ORAlertView代理方法定义 -- ORAlertViewDelegate
								> customAlertView:clickedButtonAtIndex:
									> [self submitReview] 提交评论
										> submitReview方法 
											> 得到用户提交的评论
											> 判断评论给用户加分
											> 发送数据到服务器

											> 方法中的变量含义
												> currentPhoto: 评论中带的照片
												> bowlText: 显示正在上传的文本信息
												> recDishList: 
												> diningMethod: 用餐途径
												> waitTime: 
												> scoreList: 
												> reviewTitle
												> reviewBody
												> isDraft: 是否是稿件
											> self.mainRequest = [REVIEW_MANAGER submitReviewWithPoiId 发送请求提交评论


		> WriteReviewRatingsView - 4 - 评分

		> WriteReviewDishView - 5 - 用户推荐的其他菜式名

	> PhotoDetailViewController: 图片大图展示
		> reviewHeader:DetailHeaderView - 顶部信息
			> 方法: reloadHeaderAndCaption
			> woodBgIV
			> thumbnailIV
			> userGradeIV
			> nameLbl
			> titleLbl
			> expandTitleBtn
		> detailView:PhotoDetailView - 显示图片
			>方法: reloadContent

		> PhotoDetailViewController.reloadHeaderAndCaption方法 - headerView
		> PhotoDetailViewController.reloadContent方法 - content

	> MyBookmarkViewController: 我得餐厅
-------------------------------------------------------------------------------------
> SearchTipView
	> current location --》 按钮点击触发
		> taibleView的代理方法
			didSelectRowAtIndexPath:

-------------------------------------------------------------------------------------
> OverviewViewController.TabsView - 选项卡
> 三个选项卡切换
	> infoBtn:InfoView
	> reviewsBtn:ReviewView
	> photosBtn:WaterFallPhotoView

	> 三个按钮的点击事件都在一个方法处理 - buttonAction:

		* 强制令某个tab选中(强制触发对应tab的点击事件) --> [TabsView performSelector:@slector(buttonAction:) withObj:nil];
			> 可以加个tag标示，强制选中哪个tab

		>1. 判断当前的tab
			> case 1:currentTab = TabsTypeInfo
			> case 2:currentTab = TabsTypeReviews;
			> case 3:currentTab = TabsTypePhotos;
		>2. loadContent方法 - 加载对应tab的数据
			> loadDataSource方法
				> photoRequest = [[PHOTO_MANAGER getPhotoListWithPoiId....  callback:@selector(didGetPhoto:)] retain]
					> didGetPhoto: 回掉方法中，reloadContent - 执行数据源方法
						> 瀑布流数据源方法
							> -(NSInteger)numberOfViewsInCollectionView
							> -(PSCollectionViewCell *)collectionView: viewAtIndex:
								> 自定义cell - PSBroView
									> [v:(PSBroView) fillViewWithPhotoDetail:photoDetail];
										> [self.imageView loadImageFromURL:[NSURL URLWithString:photoDetail.photoUrlSmall]];
							> -(CGFloat)heightForViewAtIndex:
							> - (void)collectionView: didSelectView:
								> PhotoDetailViewController - push到得控制器
									> PhotoDetailView
										>[photoIV loadImageFromURL:[NSURL URLWithString:[photoDetail photoUrlLarge]]];
										>[photoIV loadImageFromURL:[NSURL URLWithString:self.menuFile.fileUrlLarge]];
									    >[photoIV loadImageFromURL:[NSURL URLWithString:self.menuFile.fileUrlSmall]];

> loadContent方法 - 加载数据
-----------------------------------------------------------------------------------
	
4. XxxManaer
	
	> BookmarkManager: - 收藏管理
		> getBookmarkCategoryListWithDelegate - 获取收藏分类(1.Family Gath.. 2.Dating 3.BusinessMetting 4.FriendGathe.. 5.FoodDelivery)
		
	> RestaurantDetailManager

	> COUPON_MANAGER - 优惠券
		> BookmarkResponse *bkResponse = [COUPON_MANAGER getbookmarkCouponResultFromJSONData:[request responseData]];
		> [bkResponse.couponIsBookmarkExist isEqualToString:@"1"] - 是否已经抽藏优惠券

		> [BOOKMARK_MANAGER checkBookmarkStatusWithPoiId:poiId
											  delegate:self
											  callback:@selector(didGetBookmarkStatus:)];
            > [bookmarkResponse couponIsBookmarkExist]


            [COUPON_MANAGER addBookmarkCouponWithCouponId:couponId
                                             delegate:topVC
                                             callback:@selector(didBookmarkCoupon:)];

            BookmarkResponse *bkResponse = [COUPON_MANAGER getbookmarkCouponResultFromJSONData:[request responseData]];

            [bkResponse.couponIsBookmarkExist isEqualToString:@"1"]
------------------------------------------------------------------------------------------------------
5. 技巧性代码
	
	> UIView中 , 添加异步显示图片的代码
		
		* 可以加入将读取到得图片NSData数据，写入本地Cche目录做为缓存

		> 使用 - ASIHTTPRequest - 实现如下:
				- (void)loadImageFromURL:(NSURL*)url {

				    //1. 清空ASIHTTPRequest对象的代理
					request.delegate = nil;
				    [request clearDelegatesAndCancel];
					[request release];
					request = nil;
    
				    //2. 创建ASIHTTPRequest对象 ->>> 请求图片的url
				    request = [[ASIHTTPRequest requestWithURL:url] retain];
					
				    //3. 重新设置代理
				    [request setDelegate:self];
					
				    //4. cache
				    [request setDownloadCache:[ASIDownloadCache sharedCache]];
					//    [request setCachePolicy: ASIAskServerIfModifiedCachePolicy | ASIFallbackToCacheIfLoadFailsCachePolicy];
				    
				    //5. 缓存策略
					[request setCachePolicy:ASIUseDefaultCachePolicy];
				    [request setCacheStoragePolicy:ASICachePermanentlyCacheStoragePolicy];
				    // cache 30 天
				    [request setSecondsToCache:60 * 60 * 24 * 30];
				    // time out 自動重試的次數
				    [request setNumberOfTimesToRetryOnTimeout:2];
					
				    //6. 网络接收数据后回调处理函数

				    //6.1 请求处理成功 -> 接收到图片数据后 -> 设定回调函数 -> imageDidDownload:
				    [request setDidFinishSelector:@selector(imageDidDownload:)];

				    //6.2 请求处理失败 -> 设定回调函数 -> didServerFail:
				    [request setDidFailSelector:@selector(didServerFail:)];
					
					//	/* If we didn't set these selectors, sometimes the app will crash.*/
					//    [request setDidReceiveResponseHeadersSelector:@selector(dummySelector)];
					//    [request setDidStartSelector:@selector(dummySelector:)];
				    
				    //7. 发起 - 异步 - 网络请求
					[request startAsynchronous];
				    
				    //8. 回调函数中，取出图片的NSData数据
				    //imageDidDownload: 函数中

				    //9. NSData数据 ->>> UIImage
				}

				//网络请求回调函数 - 更新UI, 显示图片
				- (void)imageDidDownload:(ASIHTTPRequest *)_request
				{
				//	BOOL success = [request didUseCachedResponse];
				//	NSLog(@"------------>>>>>>> didUseCachedResponse is %@\n", (success ? @"YES" : @"NO"));
				//	NSLog(@"%s",__FUNCTION__);
				    // RMS
				    if (self.noImageType == NoImageHiddenWhenDownloadFail) {
				        self.hidden = FALSE;
				    }
				    // End RMS
				    NSData *imageData = [_request responseData];
				    UIImage *image = [[UIImage alloc] initWithData:imageData];
				    if (image != nil) {
				        [self setImage:image];
				    }else{
				       self.image = nil;
				    }
				    
				    
					// call our delegate and tell it that image is ready for display
					if ([delegate respondsToSelector:@selector(imageDidDownload)]) {
						[delegate performSelector:@selector(imageDidDownload)];
					}
					if ([delegate respondsToSelector:@selector(imageDidDownload:)]) {
						[delegate performSelector:@selector(imageDidDownload:) withObject:self];
					}
				    [image release];
				}


	图片缓存方案:	
		> NSURLCache
		> 图片NSData写入本地文件Cache目录			







		



